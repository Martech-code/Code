import time
from datetime import datetime
import random
import json
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException, NoSuchWindowException
from collections import defaultdict, deque
from typing import Dict, List
import os
import threading
from selenium.webdriver.common.action_chains import ActionChains

# Đường dẫn file
uid_list_file = 'D:\\Code Python\\check_groups\\uid_list.txt'
output_dir = 'D:\\Code Python\\check_groups'

# Các thông số cấu hình
MIN_DELAY_BETWEEN_REQUESTS = 0.2
MAX_DELAY_BETWEEN_REQUESTS = 0.5
MAX_RETRIES = 3
PAGE_LOAD_TIMEOUT = 6
MAX_PARALLEL_TABS = 15
TAB_SWITCH_DELAY = 0.2

class ChromeInstance:
    def __init__(self, debug_port, worker_id):
        self.debug_port = debug_port
        self.worker_id = worker_id
        self.driver = None
        self.tab_manager = None
        self.processed_count = 0
        self.is_checkpoint = False
        self.is_blocked = False

    def setup_chrome_driver(self):
        chrome_options = Options()
        chrome_options.add_experimental_option("debuggerAddress", f"127.0.0.1:{self.debug_port}")
        chrome_options.add_argument('--no-sandbox')
        chrome_options.add_argument('--disable-dev-shm-usage')
        chrome_options.add_argument('--disable-gpu')
        chrome_options.add_argument('--disable-notifications')
        chrome_options.add_argument('--disable-infobars')
        chrome_options.add_argument('--lang=vi')
        return chrome_options

    def create_driver(self):
        try:
            options = self.setup_chrome_driver()
            service = Service()
            self.driver = webdriver.Chrome(service=service, options=options)
            self.driver.set_page_load_timeout(PAGE_LOAD_TIMEOUT)
            self.tab_manager = TabManager(self.driver)
            return self.driver
        except Exception as e:
            raise Exception(f"Lỗi khởi tạo Chrome WebDriver port {self.debug_port}: {str(e)}")

    def check_suspicious(self):
        try:
            current_url = self.driver.current_url.lower()
            if "facebook.com/checkpoint/601051028565049" in current_url:
                # Tìm và nhấp vào nút "Bỏ qua" hoặc "Dismiss"
                skip_button = self.driver.find_elements(By.XPATH, "//span[contains(@class, 'x1lliihq') and contains(@class, 'x6ikm8r') and contains(@class, 'x10wlt62') and contains(@class, 'x1n2onr6') and contains(@class, 'xlyipyv') and contains(@class, 'xuxw1ft') and (contains(text(), 'Bỏ qua') or contains(text(), 'Dismiss'))]")
                if skip_button:
                    actions = ActionChains(self.driver)
                    actions.double_click(skip_button[0]).perform()
                    time.sleep(1)  # Chờ sau khi nhấp
                    return True
            return False
        except:
            return False

    def check_checkpoint(self):
        try:
            current_url = self.driver.current_url.lower()
            if "facebook.com/checkpoint/601051028565049" in current_url:
                return False
            checkpoint_indicators = [
                "facebook.com/checkpoint",
                "facebook.com/recover",
                "facebook.com/login", 
                "/login/?next",
                "checkpoint/?next"
            ]
            return any(indicator in current_url for indicator in checkpoint_indicators)
        except:
            return False

    def check_blocked(self):
        try:
            # Kiểm tra text thông báo bị chặn - cả tiếng Việt và tiếng Anh
            blocked_texts = [
                "Bạn tạm thời bị chặn",
                "You're Temporarily Blocked",
                "Có vẻ như bạn đang dùng nhầm tính năng này do sử dụng quá nhanh",
                "It looks like you were misusing this feature by going too fast. You've been temporarily blocked from using it."
            ]

            # Kiểm tra phần tử HTML reload button - cả tiếng Việt và tiếng Anh  
            reload_button = self.driver.find_elements(By.XPATH, "//span[contains(@class, 'x1lliihq') and contains(@class, 'x6ikm8r') and contains(@class, 'x10wlt62') and contains(@class, 'x1n2onr6') and contains(@class, 'xlyipyv') and contains(@class, 'xuxw1ft') and (contains(text(), 'Tải lại trang') or contains(text(), 'Reload Page'))]")

            page_source = self.driver.page_source
            text_check = any(text in page_source for text in blocked_texts)
            button_check = len(reload_button) > 0

            return text_check and button_check
        except:
            return False

def check_group_status(driver) -> bool:
    error_messages = [
        "bạn hiện không xem được nội dung này",
        "lỗi này thường do chủ sở hữu chỉ chia sẻ nội dung với một nhóm nhỏ",
        "this content isn't available",
        "when this happens, it's usually because the owner only shared it",
        "content not found",
        "đã xóa nội dung",
        "you must log in to continue"
    ]
    
    page_source = driver.page_source.lower()
    title = driver.title.lower()

    content_check = any(error_msg in page_source for error_msg in error_messages)
    title_check = title == "facebook" or "(15) facebook" in title

    return content_check or title_check

class TabManager:
    def __init__(self, driver):
        self.driver = driver
        self.tabs = []
        self.main_window = driver.current_window_handle

    def open_new_tab(self, group_id: str):
        try:
            self.driver.execute_script("window.open('about:blank', '_blank');")
            time.sleep(TAB_SWITCH_DELAY)
            new_tab = self.driver.window_handles[-1]
            self.driver.switch_to.window(new_tab)

            try:
                self.driver.get(f"https://www.facebook.com/groups/{group_id}")
                self.tabs.append((new_tab, group_id, time.time()))
                return True
            except TimeoutException:
                self.driver.close()
                self.driver.switch_to.window(self.main_window)
                return False
                
        except Exception as e:
            print(f"Lỗi khi mở tab mới cho group {group_id}: {str(e)}")
            try:
                if len(self.driver.window_handles) > 1:
                    self.driver.close()
                self.driver.switch_to.window(self.main_window)
            except:
                pass
            return False

    def check_tab(self, index: int) -> tuple:
        if index >= len(self.tabs):
            return None, None, None

        tab_id, group_id, _ = self.tabs[index]

        try:
            if tab_id not in self.driver.window_handles:
                self.tabs.pop(index)
                return group_id, None, "Tab không còn tồn tại"

            time.sleep(TAB_SWITCH_DELAY)
            self.driver.switch_to.window(tab_id)
            
            try:
                WebDriverWait(self.driver, PAGE_LOAD_TIMEOUT).until(
                    lambda x: x.execute_script("return document.readyState") == "complete"
                )
                is_inactive = check_group_status(self.driver)
            except TimeoutException:
                is_inactive = None
                
            try:
                self.driver.close()
            except:
                pass
                
            self.tabs.pop(index)
            
            try:
                self.driver.switch_to.window(self.main_window)
            except:
                if self.driver.window_handles:
                    self.driver.switch_to.window(self.driver.window_handles[0])
            
            return group_id, is_inactive, None
            
        except NoSuchWindowException:
            print(f"Tab {tab_id} đã bị đóng")
            self.tabs.pop(index)
            return group_id, None, "Tab đã bị đóng"
        except Exception as e:
            print(f"Lỗi khi kiểm tra tab {tab_id}: {str(e)}")
            try:
                if tab_id in self.driver.window_handles:
                    self.driver.switch_to.window(tab_id)
                    self.driver.close()
                self.driver.switch_to.window(self.main_window)
            except:
                pass
            self.tabs.pop(index)
            return group_id, None, str(e)

def load_progress():
    try:
        with open(output_dir + '/scan_progress.json', 'r') as f:
            return json.load(f)
    except:
        return {'scanned_uids': []}

def save_progress(scanned_uids):
    with open(output_dir + '/scan_progress.json', 'w') as f:
        json.dump({
            'scanned_uids': list(scanned_uids)
        }, f)

def worker_process(chrome_instance: ChromeInstance, group_queue: deque, scanned_uids: set, lock):
    try:
        driver = chrome_instance.create_driver()
        
        while True:
            if chrome_instance.is_checkpoint:
                print(f"[Worker {chrome_instance.worker_id}] Tài khoản bị checkpoint, dừng worker")
                break

            if chrome_instance.is_blocked:
                print(f"[Worker {chrome_instance.worker_id}] Tài khoản bị chặn tạm thời, dừng worker")
                break

            with lock:
                if not group_queue:
                    break
                current_groups = []
                for _ in range(min(MAX_PARALLEL_TABS, len(group_queue))):
                    if group_queue:
                        current_groups.append(group_queue.popleft())

            if not current_groups:
                break

            for group_id in current_groups:
                if not chrome_instance.tab_manager.open_new_tab(group_id):
                    print(f"[Worker {chrome_instance.worker_id}] ! Không thể mở tab cho group {group_id}")
                    continue

                time.sleep(random.uniform(MIN_DELAY_BETWEEN_REQUESTS, MAX_DELAY_BETWEEN_REQUESTS))

                # Kiểm tra suspicious checkpoint
                if chrome_instance.check_suspicious():
                    print(f"[Worker {chrome_instance.worker_id}] Đã xử lý checkpoint nghi ngờ, tiếp tục quét")
                    continue

                if chrome_instance.check_checkpoint():
                    chrome_instance.is_checkpoint = True
                    print(f"[Worker {chrome_instance.worker_id}] Phát hiện checkpoint, dừng worker")
                    with lock:
                        group_queue.appendleft(group_id)
                    break

                if chrome_instance.check_blocked():
                    chrome_instance.is_blocked = True
                    print(f"[Worker {chrome_instance.worker_id}] Phát hiện bị chặn tạm thời, dừng worker")
                    with lock:
                        group_queue.appendleft(group_id)
                    break

                group_id, is_inactive, error = chrome_instance.tab_manager.check_tab(0)

                if error:
                    print(f"[Worker {chrome_instance.worker_id}] ! Lỗi khi kiểm tra group {group_id}: {error}")
                    with open(output_dir + '/error_groups.txt', 'a', encoding='utf-8') as f:
                        f.write(f"{group_id}\n")
                elif is_inactive is not None:
                    output_file = '/inactive_groups.txt' if is_inactive else '/active_groups.txt'
                    with open(output_dir + output_file, 'a', encoding='utf-8') as f:
                        f.write(f"{group_id}\n")
                    
                    status_symbol = '✗' if is_inactive else '✓'
                    status_text = 'không còn' if is_inactive else 'còn'
                    print(f"[Worker {chrome_instance.worker_id}] {status_symbol} Group {group_id} {status_text} hoạt động")

                chrome_instance.processed_count += 1
                with lock:
                    scanned_uids.add(group_id)
                    if chrome_instance.processed_count % 10 == 0:
                        save_progress(scanned_uids)
    except Exception as e:
        print(f"[Worker {chrome_instance.worker_id}] Lỗi: {str(e)}")
    finally:
        if chrome_instance.driver:
            chrome_instance.driver.quit()

def main():
    with open(uid_list_file, 'r') as f:
        all_group_ids = f.read().splitlines()

    progress = load_progress()
    scanned_uids = set(progress['scanned_uids'])

    group_ids = [gid for gid in all_group_ids if gid not in scanned_uids]
    group_queue = deque(group_ids)

    total_groups = len(group_ids)
    print(f"Tổng số UID cần quét: {total_groups}")

    chrome_instances = [
        ChromeInstance(debug_port=9222, worker_id=1),
        ChromeInstance(debug_port=9223, worker_id=2),
        ChromeInstance(debug_port=9224, worker_id=3),
        ChromeInstance(debug_port=9225, worker_id=4),
        ChromeInstance(debug_port=9226, worker_id=5),
        ChromeInstance(debug_port=9227, worker_id=6)
    ]

    lock = threading.Lock()

    threads = []
    for chrome_instance in chrome_instances:
        thread = threading.Thread(
            target=worker_process,
            args=(chrome_instance, group_queue, scanned_uids, lock)
        )
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    print("\nHoàn tất quét!")

if __name__ == "__main__":
    main()
